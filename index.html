<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>"Canvas" Scrolling Game</title>
    
  </head>
  <body>
    <canvas id="canvas" width="500" height="500"></canvas>


  <script>
      // VARIABLES
    let c = document.querySelector("#canvas");
    let ctx = c.getContext("2d");
      
    let background = new Image();                  
      background.src =
          "https://webgradients.com/public/webgradients_png/008%20Rainy%20Ashville.png";
      
      let bgClouds = new Image();
        bgClouds.src =
          "clouds1.png";
      
      let fgClouds = new Image();
        fgClouds.src =
          "clouds2.png";
    
      // GAME DICTIONARIES                         // FIXME: adjust numbers after basic structure set
    let player = {x:100, y:100, radius:10, speed:5};
      
//     let benefit = {x:200, y:300, radius:20};
//     let harm = {x:300, y:400, radius:30};
    let benefit = new Image();
      benefit.src =
          "benefit.png";
    let harm = new Image();
      harm.src = 
          "harm.png";
      
    let game = {score: 0, lives: 3, level: 1, state:true};
    let cloudsBack = {x:0, y:0};
    let cloudsFront = {x:450, y:200};
    
      // FUNCTIONS // 

      // FIXME: revise how to implement python collision into JS -----------------------------
      //     and change to detect image collision 
      function are_colliding(obj1, obj2) {
          let collision = false;
        
          let radii_sum = obj1["radius"] + obj2["radius"];
          let dx = obj1["x"] - obj2["x"]; // check coordinate thing
          let dy = obj1["y"] - obj2["y"];    
          let distance = Math.sqrt(dx*dx + dy*dy);
    
          if ( distance < radii_sum ) {
            collision = true;
          }
          
          return collision;
      }
      // -------------------------------------------------------------------------------------
      
      function gameOverScreen() {
          // clear screen
          ctx.clearRect (0,0, c.width, c.height);
          // print message
          ctx.drawImage(background, 0, 0, c.width, c.height);
          ctx.font = "30px Arial";
          ctx.fillStyle = "red";
          ctx.fillText("G A M E   O V E R", 100,250);
          // print score
          ctx.font = "30px Arial";
          ctx.fillStyle = "green";
          ctx.fillText("Score: " + game["score"], 150,300);
          // option to start again?
      }
      
      function instructionsScreen() {
          // clear screen
          ctx.clearRect (0, 0, c.width, c.height);
          // print message
          ctx.drawImage(background, 0,0, c.width, c.height);
          // option to start 
      }
      
      // EVENT HANDLERS
      function moveUp(e) {
          console.log(e);
          if (e.key == "ArrowUp" || e.code == "KeyW") {
              player["y"] -= player["speed"];
          }
      }
      function moveDown(e) {
          console.log(e);
          if (e.key == "ArrowDown" || e.code == "KeyS") {
             player["y"] += player["speed"]; 
          }
      }
      
          // EVENT LISTENERS                                      
      // UP
      window.addEventListener("keydown", moveUp);
      
      // DOWN
      window.addEventListener("keydown", moveDown);
    
        // loop
    const draw = () => {
        
      // clear
      ctx.clearRect (0,0, c.width, c.height);
        
      // draw background 
      ctx.drawImage(background, 0, 0, c.width, c.height);
        ctx.drawImage(bgClouds, cloudsBack["x"], cloudsBack["y"], c.width*2, c.height*2);
        ctx.drawImage(fgClouds, cloudsFront["x"], cloudsBack["y"], c.width/2, c.height/2);

      // update values
      harm["x"] -= 5;                                        // FIXME: add "speed" to dict. -> update
      benefit["x"] -= 3;
        
      cloudsBack["x"] -= 2;
      cloudsFront["x"] -= 1;
        
      if (are_colliding(player, harm) == true) {
          game["lives"] -= 1;
          harm["x"] = harm["radius"] + c.width;
          harm["y"] = Math.floor(Math.random() * 480 + 20);
      }
        
      if (are_colliding(player, benefit) == true) {
          game["score"] += 100;
          benefit["x"] = benefit["radius"] + c.width;
          benefit["y"] = Math.floor(Math.random() * 480 + 20);
      }

      // handle edge conditions                              // FIXME: fix bounds?
      if (harm["x"] < -harm["radius"]) {                     // if out of bounds
        harm["x"] = harm["radius"] + c.width;                // reset x coord & 
        harm["y"] = Math.floor(Math.random() * 480 + 20);    // random y coord
      }
      
      if (benefit["x"] < -benefit["radius"]) {
        benefit["x"] = benefit["radius"] + c.width
        benefit["y"] = Math.floor(Math.random() * 480 + 20);
      }
        
      if (cloudsFront["x"] < -800) {
        cloudsFront["x"] = c.width - 100
        cloudsFront["y"] = Math.floor(Math.random() * 480 + 20);
      }
        
      if (cloudsBack["x"] < -800) {
        cloudsBack["x"] = c.width - 100
        cloudsBack["y"] = Math.floor(Math.random() * 480 + 20);
      }

      // draw harm object
      ctx.beginPath();
      ctx.arc(harm["x"],harm["y"],harm["radius"],0, Math.PI*2);
      ctx.closePath();
      ctx.fillStyle = "orange";
      ctx.fill();
        
      // draw benefit object
      ctx.beginPath();
      ctx.arc(benefit["x"],benefit["y"],benefit["radius"],0, Math.PI*2);
      ctx.closePath();
      ctx.fillStyle = "green";
      ctx.fill();
        
      // draw player object
      ctx.beginPath();
      ctx.arc(player["x"],player["y"],player["radius"],0, Math.PI*2);
      ctx.closePath();
      ctx.fillStyle = "cyan";
      ctx.fill();
        
      // display     Lives,    Score,    and Level
      ctx.font = "12px Arial"
      ctx.fillStyle = "blue";
      ctx.fillText("Lives: " + game["lives"], 450,25);
      ctx.fillText("Score: " + game["score"], 25,25);
      ctx.fillText("Level: " + game["level"], 25,45);
        
      if (game["lives"] == 0) {
          game["state"] = false;
      }
      else {
          game["state"] = true;
      }
        
      // repeat
      if (game["state"] == true) {
          window.requestAnimationFrame(draw);
      }
      else {
          gameOverScreen();
      }
      
      //window.requestAnimationFrame(draw);
    }
    

    draw();        // FIXME: change game-loop-structure once instructions and game-over screen decided 
     
  </script>


  </body>
</html>